LEARNIVERSE-BE/SRC


LEARNIVERSE-BE/src/base-classes/base-error.js:
import statusCodes from "../errors/status-codes.js";

class BaseError extends Error {
  constructor({ code, codeName, message, errorName }) {
    super(message);
    this.statusCode = code;
    this.errorCode = codeName;
    this.errorName = errorName;
  }

  static notFound(message = "Resource does not exist") {
    return new BaseError({
      ...statusCodes.NOT_FOUND,
      errorName: "Resource Not Found",
      message,
    });
  }

  static badRequest(message = "Bad Request") {
    return new BaseError({
      ...statusCodes.BAD_REQUEST,
      errorName: "Bad Request",
      message,
    });
  }

  static unauthorized(message = "Unauthorized") {
    return new BaseError({
      ...statusCodes.UNAUTHORIZED,
      errorName: "Unauthorized",
      message,
    });
  }

  static forbidden(message = "Forbidden") {
    return new BaseError({
      ...statusCodes.FORBIDDEN,
      errorName: "Forbidden",
      message,
    });
  }

  static serviceUnavailable(message = "Service Unavailable") {
    return new BaseError({
      ...statusCodes.SERVICE_UNAVAILABLE,
      errorName: "Service Unavailable",
      message,
    });
  }

  static invalidParams(message = "Invalid Parameters") {
    return new BaseError({
      ...statusCodes.INVALID_PARAMS,
      errorName: "Invalid Parameters",
      message,
    });
  }

  static duplicate(message = "Duplicate Found") {
    return new BaseError({
      ...statusCodes.DUPLICATE,
      errorName: "Duplicate Found",
      message,
    });
  }

  static badGateway(errorName, message = "Service Unavailable") {
    return new BaseError({
      ...statusCodes.BAD_GATEWAY,
      errorName: errorName,
      message,
    });
  }

  static internalServer(message = "Internal Server Error") {
    return new BaseError({
      ...statusCodes.INTERNAL_SERVER_ERROR,
      errorName: "Internal Server Error",
      message,
    });
  }
}

export default BaseError;


LEARNIVERSE-BE/src/base-classes/base-routes.js:
import { Router } from "express";

class BaseRoutes {
  router;

  constructor() {
    this.router = Router();
    this.routes();
  }

  routes() {
    throw new Error("Routes method must be implemented in child classes.");
  }
}

export default BaseRoutes;


LEARNIVERSE-BE/src/common/enums/role-enum.js:
const Role = Object.freeze({
    ADMIN: "ADMIN",
    STUDENT: "STUDENT",
  });
  
  export default Role;
  

LEARNIVERSE-BE/src/common/services/prisma-services.js:
import { createSoftDeleteMiddleware } from "prisma-soft-delete-middleware";
import { PrismaClient } from "@prisma/client";

export class PrismaService extends PrismaClient {
  constructor() {
    super();
  }

  async onModuleInit() {
    this.$use(
      createSoftDeleteMiddleware({
        models: {
          User: true,
        },
        defaultConfig: {
          field: "deleted_at",
          createValue: (deleted) => {
            if (deleted) return new Date();
            return null;
          },
        },
      })
    );

    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}


LEARNIVERSE-BE/src/config/db-config.js:
export default () => ({
    DB_URI: process.env.DB_URI,
  });
  


LEARNIVERSE-BE/src/config/jwt-config.js:
export default () => ({
    JWT_SECRET: process.env.JWT_SECRET,
    JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || "1h",
    JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET,
    JWT_REFRESH_EXPIRES_IN: process.env.JWT_REFRESH_EXPIRES_IN || "30d",
  });
  

LEARNIVERSE-BE/src/domains/v1/auth/auth-controller.js:
import BaseError from "../../../base-classes/base-error.js";
import { parseExpireToMs } from "../../../utils/parseExpire.js";
import { successResponse } from "../../../utils/response.js";
import AuthService from "./auth-service.js";

class AuthController {
  async login(req, res) {
    if (req.body == undefined) {
      throw BaseError.badRequest("Request body is missing");
    }

    const { email, password } = req.body;

    const data = await AuthService.login(email, password);

    res
      .cookie("refresh_token", data.refresh_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: parseExpireToMs("7d"),
      })
      .header("Authorization", `Bearer ${data.access_token}`);

    return successResponse(res, data.user, "Login successful");
  }

  async register(req, res) {
    if (req.body == undefined) {
      throw BaseError.badRequest("Request body is missing");
    }

    const { name, email, username, phone_number, password } = req.body;

    const data = await AuthService.register(
      name,
      email,
      username,
      phone_number,
      password
    );

    return successResponse(res, data.user, "Registration successful");
  }

  async refreshToken(req, res) {
    const { refresh_token } = req.cookies;

    if (!refresh_token) {
      throw BaseError.unauthorized("Refresh token not found");
    }

    const token = await AuthService.refreshToken(refresh_token);

    res.header("Authorization", `Bearer ${token.access_token}`);

    return successResponse(res, null, "Token refreshed successfully");
  }

  async me(req, res) {
    const user = req.user;

    if (!user) {
      throw BaseError.unauthorized("User not found");
    }

    const data = await AuthService.getProfile(user.id);

    return successResponse(res, data, "User profile retrieved successfully");
  }
}

export default new AuthController();

LEARNIVERSE-BE/src/domains/v1/auth/auth-routes.js:
import BaseRoutes from "../../../base-classes/base-routes.js";
import authTokenMiddleware from "../../../middlewares/auth-token-middleware.js";
import validateCredentials from "../../../middlewares/validate-credentials-middleware.js";
import tryCatch from "../../../utils/tryCatcher.js";
import authController from "./auth-controller.js";
import { loginSchema, registerSchema } from "./auth-schema.js";

class AuthRoutes extends BaseRoutes {
  routes() {
    this.router.post(
      "/login",
      validateCredentials(loginSchema),
      tryCatch(authController.login)
    );

    this.router.post(
      "/register",
      validateCredentials(registerSchema),
      tryCatch(authController.register)
    );

    this.router.post("/refresh-token", [tryCatch(authController.refreshToken)]);

    this.router.get("/me", [
      authTokenMiddleware.authenticate,
      tryCatch(authController.me),
    ]);
  }
}

export default new AuthRoutes().router;


LEARNIVERSE-BE/src/domains/v1/auth/auth-schema.js:
import Joi from "joi";

const loginSchema = Joi.object({
  email: Joi.string().required().messages({
    "string.empty": "Email is required.",
  }),
  password: Joi.string().required().messages({
    "string.empty": "Password is required.",
  }),
});

const registerSchema = Joi.object({
  name: Joi.string().required().min(4).messages({
    "string.empty": "Name is required.",
    "string.min": "Name must be at least 4 characters long.",
  }),
  username: Joi.string().required().min(3).max(50).messages({
    "string.empty": "Username is required.",
    "string.min": "Username must be at least 3 characters long.",
    "string.max": "Username must be at most 50 characters long.",
  }),
  email: Joi.string().required().email().messages({
    "string.empty": "Email is required.",
    "string.email": "Email must be a valid email address.",
  }),
  phone_number: Joi.string()
    .required()
    .pattern(/^\+?[0-9]{8,15}$/)
    .messages({
      "string.empty": "Phone number is required.",
      "string.pattern.base":
        "Phone number must be 8-15 digits, optional leading +",
    }),
  password: Joi.string()
    .required()
    .min(8)
    .pattern(/^(?=.*[A-Z])(?=.*[^a-zA-Z0-9]).{8,}$/)
    .messages({
      "string.empty": "Password is required.",
      "string.min": "Password must be at least 8 characters long.",
      "string.pattern.base":
        "Password must be at least 8 characters long, contain at least 1 uppercase letter, and 1 special character.",
    }),
  password_confirmation: Joi.string()
    .required()
    .valid(Joi.ref("password"))
    .messages({
      "string.empty": "Password confirmation is required.",
      "any.only": "Password confirmation does not match password.",
    }),
});

export { loginSchema, registerSchema };


LEARNIVERSE-BE/src/domains/v1/auth/auth-service.js:
import BaseError from "../../../base-classes/base-error.js";
import { matchPassword } from "../../../utils/passwordConfig.js";
import { PrismaService } from "../../../common/services/prisma-service.js";
import jwtConfig from "../../../config/jwt-config.js";
import {
  parseRefreshToken,
  generateAccessToken,
  generateRefreshToken,
} from "../../../utils/jwtTokenConfig.js";
import { hashPassword } from "../../../utils/passwordConfig.js";
import Role from "../../../common/enums/role-enum.js";

class AuthService {
  constructor() {
    this.prisma = new PrismaService();
    this.JWTConfig = jwtConfig();
  }

  async login(email, password) {
    let user = await this.prisma.user.findFirst({
      where: {
        email: email,
      },
    });

    if (!user) {
      throw BaseError.notFound("User not found");
    }

    const isMatch = await matchPassword(password, user.password);

    if (!isMatch) {
      throw BaseError.badRequest("Invalid credentials");
    }

    const accessToken = generateAccessToken(
      {
        id: user.id,
        role: user.role,
        type: "access",
      },
      this.JWTConfig.JWT_EXPIRES_IN
    );

    const refreshToken = generateRefreshToken(
      {
        id: user.id,
        role: user.role,
        type: "refresh",
      },
      this.JWTConfig.JWT_REFRESH_EXPIRES_IN
    );

    delete user.password;

    return { access_token: accessToken, refresh_token: refreshToken, user };
  }

  async register(name, email, username, phone_number, password) {
    const emailExists = await this.prisma.user.findFirst({
      where: {
        email: email,
      },
    });

    if (emailExists) {
      throw BaseError.badRequest("Email already taken");
    }

    const usernameExists = await this.prisma.user.findFirst({
      where: {
        username: username,
      },
    });

    if (usernameExists) {
      throw BaseError.badRequest("Username already taken");
    }

    const user = await this.prisma.user.create({
      data: {
        name,
        email,
        username,
        phone_number,
        password: await hashPassword(password),
        role: Role.STUDENT,
      },
    });

    delete user.password;

    return { user };
  }

  async refreshToken(token) {
    const decoded = parseRefreshToken(token);

    if (!decoded || decoded.type !== "refresh") {
      throw BaseError.unauthorized("Invalid token");
    }

    const user = await this.prisma.user.findUnique({
      where: {
        id: decoded.id,
      },
    });

    if (!user) {
      throw BaseError.notFound("User not found");
    }

    const accessToken = generateAccessToken(
      {
        id: user.id,
        role: decoded.role,
        type: "access",
      },
      this.JWTConfig.JWT_EXPIRES_IN
    );

    return { access_token: accessToken };
  }

  async getProfile(id) {
    const user = await this.prisma.user.findFirst({
      where: { id },
    });

    if (!user) {
      throw BaseError.notFound("User not found");
    }

    delete user.password;

    return user;
  }
}

export default new AuthService();


LEARNIVERSE-BE/src/domain/v1/course/course-controller.js:
import CourseService from "./course-service.js";
import {
  successResponse,
  createdResponse,
  updatedResponse,
} from "../../../utils/response.js";

class CourseController {
  async getAll(req, res) {
    const courses = await CourseService.getAll();
    return successResponse(res, courses, "Courses retrieved successfully");
  }

  async getById(req, res) {
    const { id } = req.params;
    const course = await CourseService.getById(id);
    return successResponse(res, course, "Course retrieved successfully");
  }

  async create(req, res) {
    const data = await CourseService.create(req.body);
    return createdResponse(res, data, "Course created successfully");
  }

  async update(req, res) {
    const { id } = req.params;
    const data = await CourseService.update(id, req.body);
    return updatedResponse(res, data, "Course updated successfully");
  }

  async remove(req, res) {
    const { id } = req.params;
    const result = await CourseService.remove(id);
    return successResponse(res, result, "Course deleted successfully");
  }

  async upload(req, res) {
    const { id } = req.params;
    const modul = await CourseService.uploadMaterial(id, req.file);
    return successResponse(res, modul, "Material uploaded successfully");
  }
}

export default new CourseController();


LEARNIVERSE-BE/src/domain/v1/course/course-routes.js:
import BaseRoutes from "../../../base-classes/base-routes.js";
import multer from "multer";
import { createCourseSchema, updateCourseSchema } from "./course-schema.js";
import validateCredentials from "../../../middlewares/validate-credentials-middleware.js";
import authTokenMiddleware from "../../../middlewares/auth-token-middleware.js";
import tryCatch from "../../../utils/tryCatcher.js";
import courseController from "./course-controller.js";

const upload = multer({ dest: "uploads/materials/" });

class CourseRoutes extends BaseRoutes {
  routes() {
    this.router.get("/", tryCatch(courseController.getAll));
    this.router.get("/:id", tryCatch(courseController.getById));

    this.router.post(
      "/",
      authTokenMiddleware.authenticate,
      validateCredentials(createCourseSchema),
      tryCatch(courseController.create)
    );

    this.router.put(
      "/:id",
      authTokenMiddleware.authenticate,
      validateCredentials(updateCourseSchema),
      tryCatch(courseController.update)
    );

    this.router.delete(
      "/:id",
      authTokenMiddleware.authenticate,
      tryCatch(courseController.remove)
    );

    this.router.post(
      "/:id/material",
      authTokenMiddleware.authenticate,
      upload.single("file"),
      tryCatch(courseController.upload)
    );
  }
}

export default new CourseRoutes().router;


LEARNIVERSE-BE/src/domain/v1/course/course-service.js:
import BaseError from "../../../base-classes/base-error.js";
import { PrismaService } from "../../../common/services/prisma-service.js";
import path from "path";
import fs from "fs";

class CourseService {
  constructor() {
    this.prisma = new PrismaService();
  }

  async getAll() {
    return this.prisma.course.findMany({
      where: { deleted_at: null },
    });
  }

  async getById(id) {
    const course = await this.prisma.course.findUnique({ where: { id } });
    if (!course) throw BaseError.notFound("Course not found");
    return course;
  }

  async create(data) {
    const existing = await this.prisma.course.findFirst({
      where: { code: data.code },
    });
    if (existing) throw BaseError.duplicate("Course code already exists");

    const course = await this.prisma.course.create({ data });
    return course;
  }

  async update(id, data) {
    const course = await this.prisma.course.findUnique({ where: { id } });
    if (!course) throw BaseError.notFound("Course not found");

    const updated = await this.prisma.course.update({
      where: { id },
      data,
    });
    return updated;
  }

  async remove(id) {
    const course = await this.prisma.course.findUnique({ where: { id } });
    if (!course) throw BaseError.notFound("Course not found");

    await this.prisma.course.update({
      where: { id },
      data: { deleted_at: new Date() },
    });
    return { message: "Course deleted successfully" };
  }

  async uploadMaterial(courseId, file) {
    const course = await this.prisma.course.findUnique({ where: { id: courseId } });
    if (!course) throw BaseError.notFound("Course not found");
    if (!file) throw BaseError.badRequest("No file uploaded");

    const uploadsDir = path.join(process.cwd(), "uploads", "materials");
    if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });

    const targetPath = path.join(uploadsDir, file.originalname);
    fs.renameSync(file.path, targetPath);

    const modul = await this.prisma.modul.create({
      data: {
        title: file.originalname,
        description: "",
        file_name: file.originalname,
        modul_uri: `/uploads/materials/${file.originalname}`,
        course_id: courseId,
      },
    });

    return modul;
  }
}

export default new CourseService();


LEARNIVERSE-BE/src/errors/error-statusCodes.js:
export const INVALID_CREDENTIALS = "INVCRED01";
export const ACCOUNT_LOCKED = "LOCKER01";
export const INVALID_SUBSCRIPTION = "UNSUBS56";
export const SERVER_PROBLEM = "SERVER_ERR_001";
export const ACCESS_DENIED = "ACCESS_DENIED";
export const DUPLICATE_FOUND = "DUPLICATE_FOUND";
export const INVALID_DATABASE_PROCESS = "DATABASE_ROLLBACK_PROCESS";
export const FAILED_DATABASE_PROCESS = "FAILED_DATABASE_PROCESS";
export const INVALID_IDENTITY = "INVALID_IDENTITY";
export const MIDTRANS_ERROR = "PAYMENTSHIP_FAILED";
export const NULL_DATA = "NULL_DATA";
export const INVALID_PARAMS = "INVALID_PARAMS_FORMAT";

LEARNIVERSE-BE/src/errors/status/codes.js:
export default {
    BAD_REQUEST: {
      code: 400,
      codeName: "BAD_REQUEST",
      message: "Bad Request",
    },
    NOT_FOUND: {
      code: 404,
      codeName: "NOT_FOUND",
      message: "Not Found",
    },
    INTERNAL_SERVER_ERROR: {
      code: 500,
      codeName: "INTERNAL_SERVER_ERROR",
      message: "Internal Server Error",
    },
    BAD_GATEWAY: {
      code: 502,
      codeName: "BAD_GATEWAY",
      message: "Bad Gateway",
    },
    UNAUTHORIZED: {
      code: 401,
      codeName: "UNAUTHORIZED",
      message: "User Unauthorized",
    },
    FORBIDDEN: {
      code: 403,
      codeName: "FORBIDDEN",
      message: "No Access",
    },
    DUPLICATE: {
      code: 450,
      codeName: "DUPLICATE",
      message: "Duplicate Found",
    },
    INVALID_PARAMS: {
      code: 477,
      codeName: "INVALID_PARAMS",
      message: "Params Format Not Registered In Application",
    },
    OK: {
      code: 200,
      codeName: "OK",
      message: "OK",
    },
    CREATED: {
      code: 201,
      codeName: "CREATED",
      message: "Created",
    },
    SERVICE_UNAVAILABLE: {
      code: 503,
      codeName: "SERVICE_UNAVAILABLE",
      message: "Service Unavailable",
    },
    UNPROCESSABLE_ENTITY: {
      code: 422,
      codeName: "UNPROCESSABLE_ENTITY",
      message: "Unprocessable Entity",
    },
  };
  
LEARNIVERSE-BE/src/middlewares/auth-token-authTokenMiddleware.js:
import BaseError from "../base-classes/base-error.js";
import jwt from "jsonwebtoken";
import { PrismaService } from "../common/services/prisma-service.js";
import jwtConfig from "../config/jwt-config.js";
import Role from "../common/enums/role-enum.js";

class AuthMiddleware {
  constructor() {
    this.JWTConfig = jwtConfig();
    this.prisma = new PrismaService();
  }

  authenticate = async (req, res, next) => {
    const authHeader = req.get("Authorization");
    const token = authHeader && authHeader.split(" ")[1];

    if (!token) {
      return next(BaseError.unauthorized("No Token Provided"));
    }

    try {
      const decoded = jwt.verify(token, this.JWTConfig.JWT_SECRET);

      if (
        !decoded ||
        !decoded.id ||
        !decoded.type ||
        decoded.type !== "access"
      ) {
        return next(BaseError.unauthorized("Invalid Token"));
      }

      if (decoded.role !== Role.STUDENT && decoded.role !== Role.ADMIN) {
        return next(BaseError.unauthorized("Invalid Token"));
      }

      const user = await this.prisma.user.findUnique({
        where: {
          id: decoded.id,
        },
      });

      if (!user) {
        return next(
          new BaseError.unauthorized(
            "Token Valid, But User Not Found in Database"
          )
        );
      }

      req.user = user;

      next();
    } catch (err) {
      let message = "Token Is Invalid Or No Longer Valid";
      if (err.message === "invalid signature") message = "Invalid Signature";
      if (err.message === "invalid token") message = "Invalid Token";
      if (err.message === "jwt expired") message = "Token Expired";

      return next(BaseError.unauthorized(message));
    }
  };

  authorizeRoles = (roles) => {
    return (req, res, next) => {
      const user = req.user;

      if (!user) {
        return next(
          new BaseError(
            401,
            statusCodes.UNAUTHORIZED.message,
            "UNAUTHORIZED",
            "User Not Authenticated"
          )
        );
      }

      if (!roles.includes(user.role)) {
        return next(
          new BaseError(
            403,
            statusCodes.FORBIDDEN.message,
            "FORBIDDEN",
            "Access Denied"
          )
        );
      }

      next();
    };
  };
}

export default new AuthMiddleware();

LEARNIVERSE-BE/src/middlewares/cors-middleware.js.:
import cors from "cors";

const allowedOrigins = ["http://localhost:3000", "http://localhost:3001"];

const corsMiddleware = cors({
  origin: function (origin, callback) {
    if (!origin) return callback(null, true);
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    } else {
      return callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true,
});

export default corsMiddleware;

LEARNIVERSE-BE/src/middlewares/error-handler-middleware.js:
import BaseError from "../base-classes/base-error.js";
import StatusCodes from "../errors/status-codes.js";

export const errorHandler = (err, req, res, _next) => {
  if (err.name === "ValidationError") {
    const errorObj = {};

    for (const error of err.details) {
      errorObj[error.path] = [error.message];
    }

    if (err.source === "query") {
      return res.status(StatusCodes.INVALID_PARAMS.code).json({
        code: StatusCodes.INVALID_PARAMS.code,
        status: StatusCodes.INVALID_PARAMS.codeName,
        message: StatusCodes.INVALID_PARAMS.message,
        pagination: null,
        data: null,
        errors: {
          name: err.name,
          message: err.message,
          validation: errorObj,
        },
      });
    }

    return res.status(StatusCodes.UNPROCESSABLE_ENTITY.code).json({
      code: StatusCodes.UNPROCESSABLE_ENTITY.code,
      status: StatusCodes.UNPROCESSABLE_ENTITY.codeName,
      message: StatusCodes.UNPROCESSABLE_ENTITY.message,
      pagination: null,
      data: null,
      errors: {
        name: err.name,
        message: err.message,
        validation: errorObj,
      },
    });
  }

  if (err.name === "MulterError") {
    if (err.code === "LIMIT_FILE_SIZE") {
      return res.status(StatusCodes.BAD_REQUEST.code).json({
        code: StatusCodes.BAD_REQUEST.code,
        status: StatusCodes.BAD_REQUEST.codeName,
        message: StatusCodes.BAD_REQUEST.message,
        pagination: null,
        data: null,
        errors: {
          name: err.name,
          message: "File size exceeds 5MB limit",
          validation: null,
        },
      });
    }

    return res.status(StatusCodes.BAD_REQUEST.code).json({
      code: StatusCodes.BAD_REQUEST.code,
      status: StatusCodes.BAD_REQUEST.codeName,
      message: StatusCodes.BAD_REQUEST.message,
      pagination: null,
      data: null,
      errors: {
        name: err.name,
        message: err.field,
        validation: null,
      },
    });
  }

  if (err instanceof BaseError) {
    return res.status(err.statusCode).json({
      code: err.statusCode, // e.g. "BAD_REQUEST"
      status: err.errorCode, // e.g. 400
      message: err.message, // e.g. "Bad Request"
      pagination: null,
      data: null,
      errors: {
        name: err.errorName, // e.g. "Bad Request"
        message: err.message, // custom message
        validation: null,
      },
    });
  }

  console.error("âŒ Error:", err);

  return res.status(StatusCodes.INTERNAL_SERVER_ERROR.code).json({
    code: StatusCodes.INTERNAL_SERVER_ERROR.code,
    status: StatusCodes.INTERNAL_SERVER_ERROR.codeName,
    message: StatusCodes.INTERNAL_SERVER_ERROR.message,
    pagination: null,
    data: null,
    errors: {
      name: err.name,
      message: err.message,
      validation: null,
    },
  });
};

export default errorHandler;

LEARNIVERSE-BE/src/middlewares/validate-credetial-middleware.js:
const validateCredentials = (schema) => (req, res, next) => {
    const validated = schema.validate(req.body, {
      abortEarly: false,
      errors: {
        wrap: {
          label: "",
        },
      },
      convert: true,
    });
  
    if (validated.error) {
      next(validated.error);
    } else {
      next();
    }
  };
  
  export default validateCredentials;
  
LEARNIVERSE-BE/src/seeders/admin-seed.js:
import { hashPassword } from "../utils/passwordConfig.js";
import { PrismaService } from "../common/services/prisma-service.js";
import Role from "../common/enums/role-enum.js";

class AdminSeeder {
  constructor() {
    this.prisma = new PrismaService();
  }

  async seed(name, username, phone_number, email, password) {
    const normalizedEmail = email.toLowerCase();
    const normalizedUsername = username.toLowerCase();

    const exists = await this.prisma.user.findFirst({
      where: { email: normalizedEmail },
      select: { id: true },
    });

    if (exists) {
      console.log(`Admin already exists: ${normalizedEmail}`);
      return;
    }

    const hashed = await hashPassword(password);

    const created = await this.prisma.user.create({
      data: {
        email: normalizedEmail,
        name: name,
        username: normalizedUsername,
        phone_number: phone_number,
        password: hashed,
        role: Role.ADMIN,
      },
      select: {
        id: true,
        name: true,
        email: true,
        created_at: true,
        updated_at: true,
      },
    });

    console.log("Admin seeded:", created);
  }
}

const seeder = new AdminSeeder();
seeder
  .seed(
    "Administrator",
    "administrator",
    "+62123123123",
    "admin@dev.com",
    "Administrator123!"
  )
  .catch((err) => {
    console.error("Seeding failed:", err);
    process.exit(1);
  })
  .finally(async () => {
    await seeder.prisma.$disconnect();
  });


LEARNIVERSE-BE/src/utils/jwtTokenConfig.js:
import jwt from "jsonwebtoken";
import logger from "./logger.js";
import jwtConfig from "../config/jwt-config.js";

const JWTConfig = jwtConfig();

const generateAccessToken = (data, time = JWTConfig.JWT_EXPIRES_IN) => {
  return jwt.sign(data, JWTConfig.JWT_SECRET, {
    expiresIn: time,
  });
};

const generateRefreshToken = (
  data,
  time = JWTConfig.JWT_REFRESH_EXPIRES_IN
) => {
  const refreshToken = jwt.sign(data, JWTConfig.JWT_REFRESH_SECRET, {
    expiresIn: time,
  });

  return refreshToken;
};

const parseAccessToken = (token) => {
  try {
    return jwt.verify(token, JWTConfig.JWT_SECRET);
  } catch (error) {
    logger.error("Invalid token:", error.message);
    return null;
  }
};

const parseRefreshToken = (token) => {
  try {
    return jwt.verify(token, JWTConfig.JWT_REFRESH_SECRET);
  } catch (error) {
    logger.error("Invalid token:", error.message);
    return null;
  }
};

export {
  generateAccessToken,
  generateRefreshToken,
  parseAccessToken,
  parseRefreshToken,
};

LEARNIVERSE-BE/src/utils/logger.js:
import { createLogger, format, transports } from "winston";

const { timestamp, combine, printf, errors } = format;

function logger() {
  const logFormat = printf(
    ({ level, message, timestamp, stack }) =>
      `${timestamp} ${level}: ${stack || message}`
  );

  return createLogger({
    format: combine(
      format.colorize(),
      timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
      errors({ stack: true }),
      logFormat
    ),
    transports: [new transports.Console()],
  });
}

export default logger();

LEARNIVERSE-BE/src/utils/parseExpire.js:
/**
 * Mengubah format durasi seperti "10m", "1h", "30s", atau "2d" menjadi milidetik.
 * @param {string} duration - Durasi dalam format angka + unit (s/m/h/d).
 * @returns {number} Durasi dalam milidetik.
 * @throws {Error} Jika format tidak valid.
 */
export function parseExpireToMs(duration) {
    if (typeof duration !== "string") {
      throw new Error("Duration must be a string");
    }
  
    const match = duration.match(/^(\d+)([smhd])$/);
    if (!match) throw new Error("Invalid duration format");
  
    const value = parseInt(match[1], 10);
    const unit = match[2];
  
    const multipliers = {
      s: 1000,
      m: 60 * 1000,
      h: 60 * 60 * 1000,
      d: 24 * 60 * 60 * 1000,
    };
  
    return value * multipliers[unit];
  }
  
LEARNIVERSE-BE/src/utils/passwordConfig.js:
import bcrypt from "bcryptjs";

const hashPassword = async (password) => {
  const salt = await bcrypt.genSalt(10);
  return await bcrypt.hash(password, salt);
};

const matchPassword = async (password, hash) => {
  return await bcrypt.compare(password, hash);
};

export { matchPassword, hashPassword };

LEARNIVERSE-BE/src/utils/response.js:
import statusCodes from "../errors/status-codes.js";

/**
 * Success response for successful operations
 * @param {any} data - The data to return in the response
 * @param {string} message - Success message
 * @returns {object} - Formatted success response
 */
export function successResponse(
  res,
  data = "Request successful",
  message = "Success",
  pagination = null
) {
  return res.status(statusCodes.OK.code).json({
    code: statusCodes.OK.code,
    status: statusCodes.OK.message,
    message: message,
    pagination: pagination,
    data: data,
    errors: null,
  });
}

/**
 * Created response for resource creation
 * @param {any} data - The newly created resource
 * @param {string} message - Success message
 * @returns {object} - Formatted created response
 */
export function createdResponse(
  res,
  data = "Resource created successfully",
  message = "Success"
) {
  return res.status(statusCodes.CREATED.code).json({
    code: statusCodes.CREATED.code,
    status: statusCodes.CREATED.message,
    message,
    pagination: null,
    data: data,
    errors: null,
  });
}

export function updatedResponse(
  res,
  data = "Resource updated successfully",
  message = "Success"
) {
  return res.status(statusCodes.OK.code).json({
    code: statusCodes.OK.code,
    status: statusCodes.OK.message,
    message,
    pagination: null,
    data: data,
    errors: null,
  });
}

LEARNIVERSE-BE/src/utils/tryCather.js:
const tryCatch = (controller) => async (req, res, next) => {
    try {
      await controller(req, res);
    } catch (err) {
      next(err);
    }
  };
  
  export default tryCatch;
  

LEARNIVERSE-BE/src/app.js:
import "dotenv/config";
import compression from "compression";
import errorHandler from "./middlewares/error-handler-middleware.js";
import express from "express";
import helmet from "helmet";
import logger from "./utils/logger.js";
import { queryParser } from "express-query-parser";
import cookieParser from "cookie-parser";
import morgan from "morgan";
import routes from "./routes.js";
import corsMiddleware from "./middlewares/cors-middleware.js";
import BaseError from "./base-classes/base-error.js";

class ExpressApplication {
  app;
  fileStorage;
  fileFilter;
  constructor(port) {
    this.app = express();
    this.port = port;

    //  __init__
    this.setupMiddlewares([
      ...(process.env.NODE_ENV === "development" ? [morgan("dev")] : []),
      helmet(),
      compression(),
      corsMiddleware,
      cookieParser(),
      express.json(),
      express.urlencoded({ extended: false }),
      queryParser({
        parseNull: true,
        parseBoolean: true,
        parseNumber: true,
      }),
    ]);
    this.setupRoute();
    // Error Handler
    this.app.use(errorHandler);
  }

  setupMiddlewares(middlewaresArr) {
    middlewaresArr.forEach((middleware) => {
      this.app.use(middleware);
    });
  }

  setupRoute() {
    this.app.use("/", routes);
    this.app.use((req) => {
      logger.error(`Route not found: ${req.method} ${req.originalUrl}`);
      throw BaseError.notFound("Route not found");
    });
  }

  start() {
    const server = this.app.listen(this.port, () => {
      logger.info(`Application running on port ${this.port}`);
    });

    return server;
  }
}

export default ExpressApplication;

LEARNIVERSE-BE/src/routes.js:
import express from "express";
import authRoutes from "./domains/v1/auth/auth-routes.js";

const router = express.Router();

const appsV1Routes = [
  {
    path: "/auth",
    route: authRoutes,
  },
];

appsV1Routes.forEach(({ path, route }) => {
  router.use(`/api/v1${path}`, route);
});

export default router;

LEARNIVERSE-BE/src/server.js:
import ExpressApplication from "./app.js";
import logger from "./utils/logger.js";

const PORT = process.env.APP_PORT || 3000;

const appInstance = new ExpressApplication(PORT);
const app = appInstance.app;

if (process.env.NODE_ENV !== "cli") {
  const server = appInstance.start();

  process.on("SIGTERM", () => {
    logger.warn("SIGTERM RECEIVED!");
    server.close(() => {
      logger.warn("Process Terminated!");
    });
  });
}

export default app;
